#!/usr/bin/env node

var fs = require('fs');
var glob = require('glob');
var path = require('path');
var shuffle = require('knuth-shuffle').knuthShuffle;
var request = require('request');

var getRequestOpts = require('./assets/get_image_request_options');

// Number of requests in flight at any given time:
const BATCH_SIZE = 1;
// Wait time before launching a new request, ms:
const BATCH_WAIT = 500;
// Request timeout, ms:
const REQ_TIMEOUT = 40000;
// Print more messages if true:
const VERBOSE = false;
// Randomize test ordering (otherwise glob sorting is used):
const RANDOMIZE = false;

/**
 *  Load Tester for imageservers
 *
 *  Usage:
 *
 *      load_test ENDPOINT_URL REQUEST_DIR
 *
 *      ENDPOINT_URL is the URL to the image generation endpoint.
 *
 *      REQUEST_DIR is a directory containing sorted requests:
 *        REQUEST_DIR/success/*  -  requests expected to succeed
 *        REQUEST_DIR/failure/*  -  requests expected to fail
 *
 */
var endpointUrl = process.argv[2];
var requestDir = process.argv[3];

var failReqs = getRequests(requestDir + '/failure/*', {'success': false});
var successReqs = getRequests(requestDir + '/success/*', {'success': true});
var mockReqs = getRequests(requestDir + '/*', {'success': true, 'mock': true});
var allReqs = failReqs.concat(successReqs, mockReqs);

var errors = 0;
var successes = 0;
var startTime = Date.now();

/**
 * Return object containing paths to all requests matching the glob.
 *
 * @param {string} requestGlob
 * @param {Object}  extraObj - data in this object will be appended to each match
 */
function getRequests(requestGlob, extraObj) {
    var matches = glob.sync(requestGlob);

    return matches.map(function(match) {
        return Object.assign({"filename": match}, extraObj);
    });
}

if(allReqs.length === 0) {
    throw new Error('No requests found in ' + requestDir);
}

if (RANDOMIZE) {
    allReqs = shuffle(allReqs);
}

console.log('test run starting');
runInBatch(allReqs);

function runInBatch(reqs) {
    var running = 0;

    for(var i = 0; i < reqs.length; i++) {
        queueReq(reqs[i]);
    }

    function queueReq(req) {
        if(running >= BATCH_SIZE) {
            setTimeout(function() {
                queueReq(req);
            }, BATCH_WAIT);
            return;
        }
        running++;

        // throttle the number of tests running concurrently

        runReq(req, function() {
            running--;
        });
    }
}

/**
 * Run a test based on the request, then call the completion function
 *
 * @param {Object}   req - the request
 * @param {function} completion - function to run on completion, no args
 */
function runReq(req, completion) {
    var totalReqs = successes + errors;
    var totalTime = (Date.now() - startTime) / 1000;
    var rps = totalReqs / totalTime;
    console.log((VERBOSE ? '  ' : '') + 'successes: ' + successes +
                ', errors: ' + errors + ', total: ' + totalReqs +
                ', time: ' + totalTime + ', rps: ' + rps);

    if (VERBOSE) {
        console.log('Starting ' + req.filename);
    }

    var reqStart = Date.now();

    function onResponse(response) {
        if(req.success && +response.statusCode !== 200) {
            console.log('  Unexpected error response on ' + req.filename);
            errors++;
        } else {
            if (VERBOSE) {
                console.log('  Success on ' + req.filename);
            }
            successes++;
        }
        if (VERBOSE) {
            console.log('  Service time: ' + (Date.now() - reqStart));
        }
        return completion();
    }

    function onError(err) {
        if(req.success) {
            console.log('  Unexpected request failure on ' + req.filename + ': ' + err);
            errors++;
        } else {
            if (VERBOSE) {
                console.log('  Expected failure on ' + req.filename);
            }
            successes++;
        }
        if (VERBOSE) {
            console.log('  Service time: ' + (Date.now() - reqStart));
        }

        return completion();
    }

    if (req.mock) {
        var body = getRequestOpts({ pathToMock: path.resolve(req.filename)}).body;
    } else {
        try {
            var body = JSON.stringify(require(req.filename));
        }
        catch(SyntaxError) {
            if(req.success) {
                console.log('  Unexpected parse failure on ' + req.filename);
                errors++;
            } else {
                if (VERBOSE) {
                    console.log('  Expected parse failure on ' + req.filename);
                }
                successes++;
            }

            return completion();
        }
    }

    request.post({uri: endpointUrl, body: body, timeout: REQ_TIMEOUT})
        .on('error', onError)
        .on('response', onResponse);
}
